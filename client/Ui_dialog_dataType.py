'''
Author: Radon
Date: 2021-04-22 14:26:43
LastEditTime: 2021-09-06 17:04:49
Description: 数据类型设置界面
'''
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'd:\VSCode_Project\python_project\fuzzProject\dialog_seed_v2.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtWidgets
import sys
import json
import random
import re
import traceback

from PyQt5 import QtCore
# from PyQt5.QtWidgets import *
from PyQt5.QtCore import QRegExp
from PyQt5.QtGui import QRegExpValidator
from PyQt5.QtWidgets import QInputDialog, QMessageBox, QHeaderView

import public
import staticAnalysis as sa

# 数据类型字典-start
# 存储数据类型的相关信息
dataTypeDict = {
    "bool": {
        "bitsize": 8,
        "lower": 0,
        "upper": 1
    },
    "char": {
        "bitsize": 8,
        "lower": -128, "upper": 127
    },
    "short": {
        "bitsize": 16,
        "lower": 0 - (1 << 15),
        "upper": (1 << 15) - 1
    },
    "int": {
        "bitsize": 32,
        "lower": 0 - (1 << 31),
        "upper": (1 << 31) - 1
    },
    "long": {
        "bitsize": 32,
        "lower": 0 - (1 << 31),
        "upper": (1 << 31) - 1
    },
    "long long": {
        "bitsize": 64,
        "lower": 0 - (1 << 63),
        "upper": (1 << 63) - 1
    },
    "unsigned char": {
        "bitsize": 8,
        "lower": 0,
        "upper": (1 << 8) - 1
    },
    "unsigned short": {
        "bitsize": 16,
        "lower": 0,
        "upper": (1 << 16) - 1
    },
    "unsigned int": {
        "bitsize": 32,
        "lower": 0,
        "upper": (1 << 32) - 1
    },
    "unsigned long": {
        "bitsize": 32,
        "lower": 0,
        "upper": (1 << 32) - 1
    },
    "unsigned long long": {
        "bitsize": 64,
        "lower": 0,
        "upper": (1 << 64) - 1
    },
    # TODO float和double的上下限太大了，看起来很长，所以暂时设置成了32位的上下限
    "float": {
        "bitsize": 32,
        "lower": float(0 - (1 << 31)),
        "upper": float((1 << 31) - 1)},
    "double": {
        "bitsize": 64,
        "lower": float(0 - (1 << 31)),
        "upper": float((1 << 31) - 1)
    }
}
# 数据类型字典-end


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        global dataTypeDict
        Dialog.setObjectName("Dialog")
        Dialog.setWindowTitle("自定义结构体成员变量值")
        Dialog.resize(900, 550)
        self.setTable(Dialog)

        self.dialog = Dialog

    def setTable(self, Dialog):  # 界面函数
        global dataTypeDict

        # 表格-start
        self.dataTypeTable = QtWidgets.QTableWidget(Dialog)
        self.dataTypeTable.setGeometry(QtCore.QRect(10, 10, 880, 480))
        self.dataTypeTable.setColumnCount(4)
        # 表格-end

        # 保存按钮-start
        self.determineBtn = QtWidgets.QPushButton(Dialog)
        self.determineBtn.setGeometry(QtCore.QRect(10, 500, 435, 40))
        self.determineBtn.setText("保存为JSON")
        self.determineBtn.clicked.connect(self.addNewDataType)
        # self.determineBtn.clicked.connect(self.saveData)
        # 保存按钮-end

        # 生成按钮-start
        self.generateBtn = QtWidgets.QPushButton(Dialog)
        self.generateBtn.setGeometry(QtCore.QRect(455, 500, 435, 40))
        self.generateBtn.setText("生成种子文件")
        # self.generateBtn.clicked.connect(self.genSeed)
        # self.generateBtn.clicked.connect(Dialog.accept)
        # 生成按钮-end

        self.setTableContent()

    # 发送一个新的dict，设置表格内容
    def setTableContent(self):
        # 获取变量数-start
        amountRows = len(dataTypeDict)
        # 获取变量数-end
        self.dataTypeTable.setRowCount(amountRows)
        self.dataTypeTable.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.dataTypeTable.setHorizontalHeaderLabels(
            ["数据类型", "位", "上限", "下限"])

        i = 0  # 行
        for key, val in dataTypeDict.items():
            self.dataTypeTable.setItem(
                i, 0, self.enableeditItem(key))  # 数据类型名
            self.dataTypeTable.setCellWidget(
                i, 1, self.lineEditItem(True, str(val["bitsize"]), "bitsize", key))  # 位
            self.dataTypeTable.setCellWidget(
                i, 2, self.lineEditItem(True, str(val["lower"]), "lower", key))  # 下限
            self.dataTypeTable.setCellWidget(
                i, 3, self.lineEditItem(True, str(val["upper"]), "upper", key))  # 上限
            i += 1
    # 结束

    def enableeditItem(self, text):  # 生成不可修改item
        enableeditItem = QtWidgets.QTableWidgetItem(text)
        enableeditItem.setFlags(
            QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        return enableeditItem
    # 表格-LineEdit-start

    def lineEditItem(self, isNumber, placeholderText, whatThing, dataTypeName):
        global dataTypeDict
        lineEdit = QtWidgets.QLineEdit()
        if isNumber:
            # 输入框文本验证-start
            reg = QRegExp("^(\-|\+)?\d+(\.\d+)?$")  # 正数、负数、小数-正则
            pValidator = QRegExpValidator()
            pValidator.setRegExp(reg)
            # 输入框文本验证-end
            lineEdit.setValidator(pValidator)  # 加入正则文本文本验证

        lineEdit.setPlaceholderText(placeholderText)

        # if whatThing == "value" and placeholderText == None:
        #     # 获取数据类型，并根据类型设置是浮点类型的值还是整数
        #     dataType = memVal.split(" ")
        #     dataType.pop(-1)
        #     dataType = " ".join(dataType)
        #     if "float" in dataType or "double" in dataType:
        #         dataTypeDict[struct][memVal]["value"] = self.getRanFloatNum(
        #             dataTypeDict[struct][memVal]["lower"], dataTypeDict[struct][memVal]["upper"])
        #         lineEdit.setPlaceholderText(
        #             "随机值(%.2f)" % dataTypeDict[struct][memVal]["value"])  # 浮点型默认文字
        #     else:
        #         dataTypeDict[struct][memVal]["value"] = self.getRanIntNum(
        #             dataTypeDict[struct][memVal]["lower"], dataTypeDict[struct][memVal]["upper"])
        #         lineEdit.setPlaceholderText(
        #             "随机值(%d)" % dataTypeDict[struct][memVal]["value"])  # 整型默认文字
        # else:
        #     lineEdit.setPlaceholderText(str(placeholderText))

        lineEdit.editingFinished.connect(
            lambda: self.editFinish(lineEdit.text(), whatThing, dataTypeName))  # 编辑-活动
        return lineEdit

    def editFinish(self, text, whatThing, dataTypeName):
        global dataTypeDict
        try:
            dataTypeDict[dataTypeName][whatThing] = int(text)
        except BaseException as e:
            print("\033[1;31m")
            traceback.print_exc()
            print("\033[0m")

    def addNewDataType(self):
        global dataTypeDict
        try:
            newDataType, okPressed = QInputDialog.getText(self.dialog, "新增数据类型", "名称:", QtWidgets.QLineEdit.Normal, "")
            if okPressed:
                if len(newDataType) <= 0:
                    inputDataTypeBox = QtWidgets.QMessageBox(QtWidgets.QMessageBox.Information, "消息", "请输入名称")
                    inputDataTypeBox.exec_()
                    return
                if newDataType in dataTypeDict.keys():
                    dataTypeExistBox = QtWidgets.QMessageBox(QtWidgets.QMessageBox.Warning, "警告", "该数据类型已存在!")
                    dataTypeExistBox.exec_()
                    return
                dataTypeDict[newDataType] = {"bitsize": 0, "lower": 0, "upper": 0}
                self.setTableContent()
        except BaseException as e:
            addErrBox = QtWidgets.QMessageBox(QtWidgets.QMessageBox.Warning, "错误", "出现错误:" + str(e))
            addErrBox.exec_()
            print("\033[1;31m")
            traceback.print_exc()
            print("\033[0m")

    def delDataType(self):
        pass

# if __name__ == "__main__":
#     app = QtWidgets.QApplication(sys.argv)
#     headerNotExistBox = QtWidgets.QMessageBox(
#         QtWidgets.QMessageBox.Information, "消息", "请运行Ui_window.py :)")
#     headerNotExistBox.exec_()


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(dialog)
    dialog.show()
    sys.exit(app.exec_())
